<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pill Assistant</title>
    <link rel="icon" href="data:,">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html {
            height: 100%;
            /* Allow touch scrolling on the document */
            touch-action: pan-y pan-x;
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: 'Roboto', sans-serif;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            min-height: 100vh;
            position: relative;
            /* Ensure touch scrolling works without needing an initial click */
            touch-action: pan-y pan-x;
        }

        /* Light theme (default) */
        body.theme-light {
            background-color: #fafafa;
            color: #212121;
        }

        /* Dark theme */
        body.theme-dark {
            background-color: #121212;
            color: #e0e0e0;
        }

        /* Auto theme - will be set by JavaScript based on system preference */
        body.theme-auto {
            background-color: var(--primary-background-color, #fafafa);
            color: var(--primary-text-color, #212121);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            /* Allow full touch scrolling */
            touch-action: auto;
            overflow: visible;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 20px;
            color: var(--primary-color, #03a9f4);
        }

        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .add-medication-btn {
            background-color: var(--primary-color, #03a9f4);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .add-medication-btn:hover {
            background-color: var(--dark-primary-color, #0288d1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }

        .add-medication-btn:active {
            transform: translateY(0);
        }

        .medication-card {
            background: var(--card-background-color, #ffffff);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        .medication-card.updating {
            opacity: 0.7;
            pointer-events: none;
        }

        .medication-card.updating::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
        }

        .medication-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--divider-color, #e0e0e0);
            padding-bottom: 10px;
        }

        .medication-name {
            font-size: 1.5em;
            font-weight: 500;
            color: var(--primary-text-color, #212121);
        }

        .medication-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
        }

        .status-scheduled { background-color: #81c784; color: white; }
        .status-due { background-color: #ff9800; color: white; }
        .status-overdue { background-color: #f44336; color: white; }
        .status-taken { background-color: #4caf50; color: white; }
        .status-refill_needed { background-color: #9c27b0; color: white; }

        .medication-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .detail-item {
            padding: 10px;
            background: var(--secondary-background-color, #f5f5f5);
            border-radius: 4px;
        }

        .detail-label {
            font-size: 0.85em;
            color: var(--secondary-text-color, #757575);
            margin-bottom: 5px;
        }

        .detail-value {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--primary-text-color, #212121);
        }

        .dosage-adjuster {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--secondary-background-color, #f5f5f5);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            margin-right: 10px;
        }

        .dosage-label {
            font-weight: 500;
            font-size: 0.9em;
            margin-right: 4px;
        }

        .adjusters-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .dosage-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dosage-btn {
            background: var(--primary-color, #03a9f4);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .dosage-btn:hover {
            background: var(--dark-primary-color, #0288d1);
        }

        .dosage-btn:disabled {
            background: var(--disabled-text-color, #9e9e9e);
            cursor: not-allowed;
        }

        .dosage-value {
            font-size: 1.1em;
            font-weight: 500;
            min-width: 80px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            flex: 1 1 auto;
            min-width: 120px;
            max-width: 200px;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .btn-take {
            background: #4caf50;
            color: white;
        }

        .btn-take:hover {
            background: #45a049;
        }

        .btn-skip {
            background: #ff9800;
            color: white;
        }

        .btn-skip:hover {
            background: #f57c00;
        }

        .btn-refill {
            background: #9c27b0;
            color: white;
        }

        .btn-refill:hover {
            background: #7b1fa2;
        }

        .btn-test {
            background: #03a9f4;
            color: white;
        }

        .btn-test:hover {
            background: #0288d1;
        }

        .btn-edit {
            background: #2196f3;
            color: white;
        }

        .btn-edit:hover {
            background: #1976d2;
        }

        .btn-delete {
            background: #f44336;
            color: white;
        }

        .btn-delete:hover {
            background: #d32f2f;
        }

        .card-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .card-management-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--divider-color, #e0e0e0);
        }

        .settings-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            cursor: pointer;
            user-select: none;
        }

        .settings-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .theme-switcher {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .theme-switcher-label {
            font-size: 0.9em;
            margin-right: 4px;
        }

        .theme-option {
            position: relative;
        }

        .theme-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .theme-option label {
            display: inline-block;
            padding: 6px 14px;
            border: 2px solid var(--divider-color, #e0e0e0);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s ease;
            user-select: none;
            background: var(--card-background-color, #ffffff);
            color: var(--primary-text-color, #212121);
        }

        .theme-option input[type="radio"]:checked + label {
            background: var(--primary-color, #03a9f4);
            color: white;
            border-color: var(--primary-color, #03a9f4);
        }

        .theme-option input[type="radio"]:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .theme-option label:hover {
            border-color: var(--primary-color, #03a9f4);
        }

        .theme-option input[type="radio"]:checked + label:hover {
            background: var(--dark-primary-color, #0288d1);
        }

        /* Sizing controls */
        .sizing-controls {
            display: none;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            margin-bottom: 15px;
            background: var(--card-background-color, #ffffff);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sizing-controls.visible {
            display: flex;
        }

        .sizing-slider-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 200px;
        }

        .sizing-slider-group label {
            font-size: 0.85em;
            font-weight: 500;
            color: var(--secondary-text-color, #757575);
        }

        .sizing-slider-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .sizing-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            cursor: pointer;
            user-select: none;
            color: var(--secondary-text-color, #757575);
        }

        .sizing-toggle input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        body.theme-dark .sizing-controls {
            background: #1e1e1e;
        }

        body.theme-dark .sizing-slider-group label {
            color: #b0b0b0;
        }

        /* Chart type toggle */
        .chart-type-toggle {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .chart-type-toggle label {
            font-size: 0.85em;
            font-weight: 500;
            color: var(--secondary-text-color, #757575);
            margin-right: 8px;
        }

        .chart-type-btn {
            padding: 6px 14px;
            border: 2px solid var(--divider-color, #e0e0e0);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s ease;
            background: var(--card-background-color, #ffffff);
            color: var(--primary-text-color, #212121);
        }

        .chart-type-btn.active {
            background: var(--primary-color, #03a9f4);
            color: white;
            border-color: var(--primary-color, #03a9f4);
        }

        .chart-type-btn:hover:not(.active) {
            border-color: var(--primary-color, #03a9f4);
        }

        body.theme-dark .chart-type-btn {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }

        body.theme-dark .chart-type-btn.active {
            background: var(--primary-color, #03a9f4);
            color: white;
            border-color: var(--primary-color, #03a9f4);
        }

        body.theme-dark .chart-type-toggle label {
            color: #b0b0b0;
        }

        /* Per-medication statistics button */
        .btn-stats {
            background: #673ab7;
            color: white;
        }

        .btn-stats:hover {
            background: #512da8;
        }

        /* Theme-specific card backgrounds */
        body.theme-dark .medication-card {
            background: #1e1e1e;
        }

        body.theme-dark .detail-item {
            background: #2a2a2a;
        }

        body.theme-dark .dosage-adjuster {
            background: #2a2a2a;
        }

        body.theme-dark .theme-option label {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }

        body.theme-dark .theme-option input[type="radio"]:checked + label {
            background: var(--primary-color, #03a9f4);
            color: white;
            border-color: var(--primary-color, #03a9f4);
        }

        /* Theme-specific text colors */
        body.theme-dark .medication-name {
            color: #ffffff;
        }

        body.theme-dark .detail-label {
            color: #b0b0b0;
        }

        body.theme-dark .detail-value {
            color: #ffffff;
        }

        body.theme-dark .dosage-label {
            color: #e0e0e0;
        }

        body.theme-dark .dosage-value {
            color: #ffffff;
        }

        body.theme-dark .theme-switcher-label {
            color: #e0e0e0;
        }

        body.theme-dark .settings-checkbox {
            color: #e0e0e0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: var(--secondary-text-color, #757575);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 15px 25px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f44336;
            color: white;
            padding: 15px 25px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--secondary-text-color, #757575);
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            opacity: 0.5;
            margin-bottom: 20px;
        }

        /* Navigation tabs */
        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--divider-color, #e0e0e0);
        }

        .nav-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--secondary-text-color, #757575);
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            top: 2px;
        }

        .nav-tab:hover {
            color: var(--primary-color, #03a9f4);
        }

        .nav-tab.active {
            color: var(--primary-color, #03a9f4);
            border-bottom-color: var(--primary-color, #03a9f4);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Statistics section */
        .statistics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .date-range-picker-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
        }

        .date-preset-options {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-preset-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            cursor: pointer;
            user-select: none;
            color: var(--primary-text-color, #212121);
        }

        .date-preset-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .date-preset-btn {
            padding: 6px 12px;
            background: var(--secondary-background-color, #f5f5f5);
            color: var(--primary-text-color, #212121);
            border: 1px solid var(--divider-color, #e0e0e0);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }

        .date-preset-btn:hover {
            background: var(--primary-color, #03a9f4);
            color: white;
            border-color: var(--primary-color, #03a9f4);
        }

        body.theme-dark .date-preset-btn {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }

        body.theme-dark .date-preset-btn:hover {
            background: var(--primary-color, #03a9f4);
            color: white;
        }

        body.theme-dark .date-preset-checkbox {
            color: #e0e0e0;
        }

        .date-time-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .date-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .date-input-group label {
            min-width: 40px;
        }

        .date-range-picker input[type="time"] {
            padding: 8px 8px;
            border: 2px solid var(--divider-color, #e0e0e0);
            border-radius: 6px;
            background: var(--card-background-color, #ffffff);
            color: var(--primary-text-color, #212121);
            font-size: 0.85em;
            width: 90px;
        }

        body.theme-dark .date-range-picker input[type="time"] {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }

        .update-btn {
            align-self: flex-end;
        }

        .date-range-picker {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .date-range-picker label {
            font-size: 0.9em;
            color: var(--secondary-text-color, #757575);
        }

        .date-range-picker input[type="date"] {
            padding: 8px 12px;
            border: 2px solid var(--divider-color, #e0e0e0);
            border-radius: 6px;
            background: var(--card-background-color, #ffffff);
            color: var(--primary-text-color, #212121);
            font-size: 0.9em;
        }

        .date-range-picker button {
            padding: 8px 16px;
            background: var(--primary-color, #03a9f4);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: background 0.3s;
        }

        .date-range-picker button:hover {
            background: var(--dark-primary-color, #0288d1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--card-background-color, #ffffff);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            font-size: 0.9em;
            color: var(--secondary-text-color, #757575);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .stat-card .stat-value {
            font-size: 2em;
            font-weight: 600;
            color: var(--primary-text-color, #212121);
        }

        .chart-container {
            background: var(--card-background-color, #ffffff);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chart-container h2 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: var(--primary-text-color, #212121);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }

        /* Dark theme adjustments for statistics */
        body.theme-dark .stat-card {
            background: #1e1e1e;
        }

        body.theme-dark .chart-container {
            background: #1e1e1e;
        }

        body.theme-dark .date-range-picker input[type="date"] {
            background: #2a2a2a;
            color: #e0e0e0;
            border-color: #444;
        }

        body.theme-dark .stat-card .stat-value {
            color: #ffffff;
        }

        body.theme-dark .chart-container h2 {
            color: #ffffff;
        }

        /* Clock visualization styles */

/* 3-column grid:
   - left spacer (1fr)
   - clocks (auto)
   - legend (1fr)
   This keeps clocks centered even when the legend exists on the right. */
.clock-layout {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    grid-template-areas: "spacer clocks legend";
    column-gap: 32px;
    row-gap: 16px;
    align-items: start;
    margin-top: 20px;
}

.clock-layout-spacer {
    grid-area: spacer;
}

/* Keep your existing flex behavior for the clocks themselves */
.clock-container {
    grid-area: clocks;
    display: flex;
    gap: 40px;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
    margin-top: 0; /* moved to .clock-layout */
}

/* Use a grid inside each clock wrapper so both clocks reserve the same ‚Äúheader‚Äù space */
.clock-wrapper {
    display: grid;
    grid-template-rows: auto 38px auto; /* label / toggle row / svg */
    justify-items: center;
    align-items: start;
    row-gap: 12px;

    min-height: 380px;
    flex: 0 0 auto;
}

/* Standardize the toggle row height so the SVGs align across wrappers */
.clock-toggle {
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: center;
    height: 38px;
}

.clock-toggle--spacer {
    visibility: hidden; /* takes space, but not visible */
}

/* Keep your existing button styling */
.clock-toggle button {
    padding: 8px 16px;
    border: 1px solid var(--divider-color, #e0e0e0);
    background: var(--card-background-color, #ffffff);
    color: var(--primary-text-color, #212121);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.clock-toggle button.active {
    background: var(--primary-color, #03a9f4);
    color: white;
    border-color: var(--primary-color, #03a9f4);
}

.clock-svg {
    position: relative;
    display: block;
}

.clock-wedge {
    cursor: pointer;
    transition: opacity 0.2s ease;
}

.clock-wedge:hover {
    opacity: 0.8;
}

/* IMPORTANT: inherit text color so labels work in light/dark automatically */
.clock-label {
    font-size: 0.9em;
    font-weight: 500;
    color: inherit;
}

.clock-date-picker {
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: center;
    margin-bottom: 15px;
}

.clock-date-picker label {
    font-weight: 500;
    color: inherit;
}

.clock-date-picker input[type="date"] {
    padding: 8px 12px;
    border: 1px solid var(--divider-color, #e0e0e0);
    background: var(--card-background-color, #ffffff);
    color: var(--primary-text-color, #212121);
    border-radius: 4px;
    font-size: 1em;
}

.clock-view-toggle {
    display: flex;
    justify-content: center;
    margin-bottom: 15px;
}

.clock-view-checkbox {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
    cursor: pointer;
    user-select: none;
    color: inherit; /* inherit for light/dark */
}

.clock-view-checkbox input[type="checkbox"] {
    cursor: pointer;
    width: 18px;
    height: 18px;
}

/* Legend sits in the RIGHT grid column, but is visually right-of-clocks.
   On wide screens: vertical list (like a sidebar legend) */
.clock-legend {
    grid-area: legend;
    display: flex;
    flex-direction: column;
    gap: 12px;
    justify-content: flex-start;
    align-items: flex-start;
    margin-top: 0; /* moved to .clock-layout */
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
}

.legend-text {
    font-size: 0.9em;
    color: inherit; /* inherit for light/dark */
}

/* Dark theme adjustments that your existing styles already do for inputs/buttons */
body.theme-dark .clock-toggle button {
    background: #2a2a2a;
    color: #e0e0e0;
    border-color: #444;
}

body.theme-dark .clock-date-picker input[type="date"] {
    background: #2a2a2a;
    color: #e0e0e0;
    border-color: #444;
}

/* Breakpoint: stack legend under clocks (bottom-right aligned) */
@media (max-width: 900px) {
    .clock-layout {
        grid-template-columns: 1fr;
        grid-template-areas:
            "clocks"
            "legend";
        column-gap: 0;
    }

    .clock-layout-spacer {
        display: none;
    }

    /* Legend becomes a row aligned to the right under the clocks */
    .clock-legend {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
        width: 100%;
        margin-top: 8px;
    }
}

        body.theme-dark .clock-view-checkbox {
            color: #e0e0e0;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            .medication-card {
                padding: 15px;
                margin-bottom: 15px;
            }

            .medication-details {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .action-buttons {
                flex-direction: column;
                gap: 8px;
            }

            .action-btn {
                min-width: 100%;
                width: 100%;
            }

            .adjusters-container {
                flex-direction: column;
                width: 100%;
                gap: 10px;
            }

            .dosage-adjuster {
                width: 100%;
                margin-right: 0;
            }

            .success-message,
            .error-message {
                left: 10px;
                right: 10px;
                top: 10px;
            }

            .header-section > div {
                width: 100%;
                justify-content: space-between;
            }

            .theme-switcher {
                order: -1;
                width: 100%;
                justify-content: center;
                margin-bottom: 10px;
            }

            .nav-tabs {
                overflow-x: auto;
                flex-wrap: nowrap;
            }

            .nav-tab {
                white-space: nowrap;
            }

            .statistics-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .date-range-picker {
                width: 100%;
            }

            .date-range-picker input[type="date"] {
                flex: 1;
            }

            .chart-wrapper {
                height: 300px;
            }

            .clock-container {
                flex-direction: column;
                gap: 30px;
            }

            /* Ensure management buttons (Edit/Delete) are visible on mobile */
            .card-management-actions {
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }

            .card-management-actions .action-btn {
                min-width: 100%;
                width: 100%;
            }

            /* Sizing controls for mobile */
            .sizing-controls {
                flex-direction: column;
                gap: 10px;
            }

            .sizing-slider-group {
                width: 100%;
            }

            .sizing-slider-group input[type="range"] {
                width: 100%;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <h1>üíä Pill Assistant</h1>
            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                <div class="theme-switcher">
                    <span class="theme-switcher-label">Theme:</span>
                    <div class="theme-option">
                        <input type="radio" id="theme-light" name="theme" value="light" onchange="setTheme('light')">
                        <label for="theme-light">‚òÄÔ∏è Light</label>
                    </div>
                    <div class="theme-option">
                        <input type="radio" id="theme-dark" name="theme" value="dark" onchange="setTheme('dark')">
                        <label for="theme-dark">üåô Dark</label>
                    </div>
                    <div class="theme-option">
                        <input type="radio" id="theme-auto" name="theme" value="auto" onchange="setTheme('auto')" checked>
                        <label for="theme-auto">üîÑ Auto</label>
                    </div>
                </div>
                <label class="settings-checkbox">
                    <input type="checkbox" id="showConfirmationBanner" checked onchange="toggleConfirmationBanner()">
                    <span>Display Confirmation Banner</span>
                </label>
                <button class="add-medication-btn" onclick="addMedication()">
                    ‚ûï Add Medication
                </button>
            </div>
        </div>

        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('medications', event)">
                üíä Medications
            </button>
            <button class="nav-tab" id="nav-statistics-tab" onclick="switchTab('statistics', event)">
                üìä Statistics
            </button>
        </div>

        <!-- Sizing Controls Toggle -->
        <label class="sizing-toggle">
            <input type="checkbox" id="editSizingSliders" onchange="toggleSizingControls()">
            <span>Edit Sizing Sliders</span>
        </label>

        <!-- Sizing Controls (hidden by default) -->
        <div id="sizingControls" class="sizing-controls">
            <div class="sizing-slider-group">
                <label for="buttonSizeSlider">Button Size: <span id="buttonSizeValue">100</span>%</label>
                <input type="range" id="buttonSizeSlider" min="50" max="150" value="100" onchange="updateButtonSize(this.value)">
            </div>
            <div class="sizing-slider-group">
                <label for="textSizeSlider">Text Size: <span id="textSizeValue">100</span>%</label>
                <input type="range" id="textSizeSlider" min="50" max="150" value="100" onchange="updateTextSize(this.value)">
            </div>
        </div>

        <!-- Medications Tab -->
        <div id="medications-tab" class="tab-content active">
            <div id="content">
                <div class="loading">Loading medications...</div>
            </div>
        </div>

        <!-- Statistics Tab -->
        <div id="statistics-tab" class="tab-content">
            <div class="statistics-header">
                <h2>Medication Statistics</h2>
                <div class="date-range-picker-container">
                    <div class="date-preset-options">
                        <label class="date-preset-checkbox">
                            <input type="checkbox" id="stats-today-checkbox" onchange="setToday()" checked>
                            <span>Today</span>
                        </label>
                        <button class="date-preset-btn" onclick="setLast7Days()">Last 7 Days</button>
                        <button class="date-preset-btn" onclick="setLast30Days()">Last 30 Days</button>
                    </div>
                    <div class="date-range-picker">
                        <div class="date-time-group">
                            <div class="date-input-group">
                                <label>Start:</label>
                                <input type="time" id="stats-start-time" onchange="onDateRangeChange()" value="00:00">
                                <input type="date" id="stats-start-date" onchange="onDateRangeChange()">
                            </div>
                            <div class="date-input-group">
                                <label>End:</label>
                                <input type="time" id="stats-end-time" onchange="onDateRangeChange()" value="23:59">
                                <input type="date" id="stats-end-date" onchange="onDateRangeChange()">
                            </div>
                        </div>
                        <button class="update-btn" onclick="loadStatistics()">Update</button>
                    </div>
                </div>
            </div>

            <!-- Chart Type Toggle -->
            <div class="chart-type-toggle">
                <label>Chart Type:</label>
                <button class="chart-type-btn active" id="chart-type-clock" onclick="setChartType('clock')">üïê Clock-Pie</button>
                <button class="chart-type-btn" id="chart-type-bar" onclick="setChartType('bar')">üìä Bar</button>
                <button class="chart-type-btn" id="chart-type-plot" onclick="setChartType('plot')">üìà Plot</button>
            </div>

            <div id="stats-summary" class="stats-grid">
                <!-- Summary stats will be inserted here -->
            </div>

            <div class="chart-container">
                <h2>Medications Taken Over Time</h2>
                <div class="chart-wrapper">
                    <canvas id="trendsChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h2>Adherence by Medication</h2>
                <div class="chart-wrapper">
                    <canvas id="adherenceChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h2>Daily Medication Timeline</h2>
                
                <div class="clock-date-picker">
                    <label for="clock-date-picker">Select Date:</label>
                    <input type="date" id="clock-date-picker" onchange="loadClockData(this.value)">
                </div>

                <div class="clock-view-toggle">
                    <label class="clock-view-checkbox">
                        <input type="checkbox" id="show-24hr-clock" onchange="toggle24HourClock()">
                        <span>Show 24-Hour Clock</span>
                    </label>
                </div>

                <div class="clock-layout">
    <div class="clock-layout-spacer" aria-hidden="true"></div>

    <div class="clock-container">
        <div class="clock-wrapper" id="clock-12hr-wrapper">
            <div class="clock-label">12-Hour Clock</div>

            <div class="clock-toggle">
                <button id="am-btn" class="active" onclick="toggleClockPeriod('AM')">AM</button>
                <button id="pm-btn" onclick="toggleClockPeriod('PM')">PM</button>
            </div>

            <svg id="clock-12hr" class="clock-svg" width="300" height="300" viewBox="-150 -150 300 300">
                <!-- Clock face will be drawn here -->
            </svg>
        </div>

        <div class="clock-wrapper" id="clock-24hr-wrapper" style="display: none;">
            <div class="clock-label">24-Hour Clock</div>

            <!-- Spacer row so the SVG lines up with the 12hr clock SVG -->
            <div class="clock-toggle clock-toggle--spacer" aria-hidden="true"></div>

            <svg id="clock-24hr" class="clock-svg" width="300" height="300" viewBox="-150 -150 300 300">
                <!-- Clock face will be drawn here -->
            </svg>
        </div>
    </div>

    <div class="clock-legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #4caf50;"></div>
            <div class="legend-text">Taken</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffc107;"></div>
            <div class="legend-text">Delayed/Snoozed</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f44336;"></div>
            <div class="legend-text">Skipped</div>
        </div>
    </div>
</div>
            </div>
        </div>
    </div>

    <script>
        // Configuration constants
        const SUBSCRIPTION_MAX_ATTEMPTS = 10;
        const SUBSCRIPTION_BASE_DELAY_MS = 1000;
        const SUBSCRIPTION_MAX_DELAY_MS = 5000;
        const RELOAD_DELAY_MS = 100;
        const POLL_INTERVAL_MS = 30000;
        const STATE_UPDATE_DELAY_MS = 100; // Delay to allow backend state propagation
        const DATE_CHANGE_DEBOUNCE_MS = 300; // Debounce delay for date/time changes

        let hass = null;
        let medications = [];
        let showConfirmationBanner = true;
        let currentTheme = 'auto'; // Default theme
        let nextScheduleCache = {}; // Cache for next scheduled times
        let darkModeMediaQuery = null; // Media query for system dark mode
        let dateChangeDebounceTimer = null; // Timer for debouncing date/time changes

        // Helper function to unwrap service response from various formats
        function unwrapServiceResponse(response) {
            if (!response || typeof response !== 'object') {
                return null;
            }
            // Try wrapped response first (from callWS)
            if ('response' in response && response.response) {
                return response.response;
            }
            // Try direct response (has expected properties)
            if ('medications' in response || 'daily_counts' in response || 'total_entries' in response) {
                return response;
            }
            return null;
        }

        // Theme management functions
        function initTheme() {
            // Load saved theme preference
            const saved = localStorage.getItem('pillAssistantTheme');
            currentTheme = saved || 'auto';
            
            // Set up media query listener for auto mode
            darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            darkModeMediaQuery.addEventListener('change', handleSystemThemeChange);
            
            // Apply initial theme
            applyTheme(currentTheme);
            
            // Update radio button state
            const radio = document.getElementById(`theme-${currentTheme}`);
            if (radio) {
                radio.checked = true;
            }
        }

        function handleSystemThemeChange(e) {
            // Only apply if we're in auto mode
            if (currentTheme === 'auto') {
                applyAutoTheme();
            }
        }

        function setTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('pillAssistantTheme', theme);
            applyTheme(theme);
        }

        function applyTheme(theme) {
            // Remove all theme classes
            document.body.classList.remove('theme-light', 'theme-dark', 'theme-auto');
            
            if (theme === 'auto') {
                // For auto mode, we don't add the 'theme-auto' CSS class because it uses
                // CSS variable fallbacks (--primary-background-color with light fallback)
                // that don't dynamically adapt. Instead, we detect the actual system/HA
                // preference and apply theme-light or theme-dark directly.
                applyAutoTheme();
            } else if (theme === 'light') {
                document.body.classList.add('theme-light');
            } else if (theme === 'dark') {
                document.body.classList.add('theme-dark');
            }
        }

        function applyAutoTheme() {
            // Check multiple methods for system dark mode preference
            // 1. CSS media query (most reliable for browsers)
            // 2. Home Assistant theme detection via CSS variable luminance
            let prefersDark = false;
            
            // Check CSS media query - this is the primary method
            if (darkModeMediaQuery) {
                prefersDark = darkModeMediaQuery.matches;
            }
            
            // Also check for Home Assistant dark theme (via CSS variables if set)
            // This helps when embedded in Home Assistant app which may not correctly
            // report prefers-color-scheme (e.g., Android WebView, iOS HA app).
            // We detect dark mode by analyzing the computed background color luminance.
            if (!prefersDark && hass) {
                // Check if Home Assistant has a dark theme active
                try {
                    const computedStyle = getComputedStyle(document.documentElement);
                    const primaryBg = computedStyle.getPropertyValue('--primary-background-color');
                    // If the primary background is very dark, assume dark mode
                    if (primaryBg && primaryBg.trim()) {
                        // Extract RGB values - works for rgb(), rgba() formats
                        // Note: For hex colors like #121212, getComputedStyle often returns rgb()
                        const rgb = primaryBg.match(/\d+/g);
                        if (rgb && rgb.length >= 3) {
                            // ITU-R BT.709 relative luminance formula coefficients
                            // Standard weights for perceived brightness
                            const RED_WEIGHT = 0.299;
                            const GREEN_WEIGHT = 0.587;
                            const BLUE_WEIGHT = 0.114;
                            const DARK_THRESHOLD = 50; // Luminance below this is considered dark
                            
                            const luminance = (
                                RED_WEIGHT * parseInt(rgb[0]) +
                                GREEN_WEIGHT * parseInt(rgb[1]) +
                                BLUE_WEIGHT * parseInt(rgb[2])
                            );
                            if (luminance < DARK_THRESHOLD) {
                                prefersDark = true;
                            }
                        }
                    }
                } catch (e) {
                    console.debug('Pill Assistant: Could not detect HA theme', e);
                }
            }
            
            // Remove both theme classes first to avoid conflicts
            document.body.classList.remove('theme-light', 'theme-dark');
            
            if (prefersDark) {
                document.body.classList.add('theme-dark');
            } else {
                document.body.classList.add('theme-light');
            }
        }

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('pillAssistantSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    showConfirmationBanner = settings.showConfirmationBanner !== false;
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
            
            // Update checkbox state
            const checkbox = document.getElementById('showConfirmationBanner');
            if (checkbox) {
                checkbox.checked = showConfirmationBanner;
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('pillAssistantSettings', JSON.stringify({
                showConfirmationBanner: showConfirmationBanner
            }));
        }

        // Toggle confirmation banner setting
        function toggleConfirmationBanner() {
            showConfirmationBanner = document.getElementById('showConfirmationBanner').checked;
            saveSettings();
        }

        // ============== Sizing Controls ==============
        let buttonSizeScale = 100;
        let textSizeScale = 100;
        let currentChartType = 'clock';

        function toggleSizingControls() {
            const checkbox = document.getElementById('editSizingSliders');
            const controls = document.getElementById('sizingControls');
            if (checkbox && controls) {
                controls.classList.toggle('visible', checkbox.checked);
            }
        }

        function updateButtonSize(value) {
            buttonSizeScale = parseInt(value);
            document.getElementById('buttonSizeValue').textContent = value;
            const scale = buttonSizeScale / 100;
            
            // Apply size to action buttons
            document.querySelectorAll('.action-btn').forEach(btn => {
                btn.style.transform = `scale(${scale})`;
                btn.style.transformOrigin = 'center';
            });
            
            // Save preference
            saveSizingSettings();
        }

        function updateTextSize(value) {
            textSizeScale = parseInt(value);
            document.getElementById('textSizeValue').textContent = value;
            const scale = textSizeScale / 100;
            
            // Apply size to text elements while maintaining relative proportions
            document.querySelectorAll('.medication-name').forEach(el => {
                el.style.fontSize = `${1.5 * scale}em`;
            });
            document.querySelectorAll('.detail-label, .detail-value').forEach(el => {
                el.style.fontSize = `${0.9 * scale}em`;
            });
            document.querySelectorAll('.dosage-label').forEach(el => {
                el.style.fontSize = `${0.9 * scale}em`;
            });
            document.querySelectorAll('.dosage-value').forEach(el => {
                el.style.fontSize = `${1.1 * scale}em`;
            });
            
            // Save preference
            saveSizingSettings();
        }

        function saveSizingSettings() {
            localStorage.setItem('pillAssistantSizing', JSON.stringify({
                buttonSize: buttonSizeScale,
                textSize: textSizeScale
            }));
        }

        function loadSizingSettings() {
            const saved = localStorage.getItem('pillAssistantSizing');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    if (settings.buttonSize) {
                        buttonSizeScale = settings.buttonSize;
                        const slider = document.getElementById('buttonSizeSlider');
                        if (slider) {
                            slider.value = buttonSizeScale;
                            updateButtonSize(buttonSizeScale);
                        }
                    }
                    if (settings.textSize) {
                        textSizeScale = settings.textSize;
                        const slider = document.getElementById('textSizeSlider');
                        if (slider) {
                            slider.value = textSizeScale;
                            updateTextSize(textSizeScale);
                        }
                    }
                } catch (e) {
                    console.error('Error loading sizing settings:', e);
                }
            }
        }

        // ============== Chart Type Toggle ==============
        function setChartType(type) {
            currentChartType = type;
            
            // Update button active states
            document.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`chart-type-${type}`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // Show/hide appropriate chart containers
            // Note: Each chart is inside a .chart-container parent
            const trendsContainer = document.querySelector('#trendsChart')?.closest('.chart-container');
            const adherenceContainer = document.querySelector('#adherenceChart')?.closest('.chart-container');
            // Clock is inside .chart-container > .clock-container, so query the parent
            const clockContainerParent = document.querySelector('.clock-container')?.closest('.chart-container');
            
            if (trendsContainer) trendsContainer.style.display = (type === 'plot' || type === 'bar') ? 'block' : 'none';
            if (adherenceContainer) adherenceContainer.style.display = (type === 'bar') ? 'block' : 'none';
            if (clockContainerParent) clockContainerParent.style.display = (type === 'clock') ? 'block' : 'none';
            
            // Save preference
            localStorage.setItem('pillAssistantChartType', type);
            
            // Re-render charts if we have stats data
            if (currentStats && (type === 'plot' || type === 'bar')) {
                renderTrendsChart(currentStats);
                if (type === 'bar') {
                    renderAdherenceChart(currentStats);
                }
            }
        }

        function loadChartTypePreference() {
            const saved = localStorage.getItem('pillAssistantChartType');
            if (saved && ['clock', 'bar', 'plot'].includes(saved)) {
                setChartType(saved);
            } else {
                setChartType('clock');
            }
        }

        // ============== Per-Medication Statistics ==============
        function showMedicationStats(medId, medName) {
            // Switch to statistics tab
            switchTab('statistics');
            
            // Set the date range to today by default
            const today = new Date();
            document.getElementById('stats-start-date').valueAsDate = today;
            document.getElementById('stats-end-date').valueAsDate = today;
            
            // Check the today checkbox
            const checkbox = document.getElementById('stats-today-checkbox');
            if (checkbox) {
                checkbox.checked = true;
            }
            
            // Load statistics with medication filter
            loadStatisticsForMedication(medId, medName);
        }

        async function loadStatisticsForMedication(medId, medName) {
            try {
                if (!hass) {
                    hass = getHassConnection();
                    if (!hass) {
                        console.error('Home Assistant connection not available');
                        return;
                    }
                }

                const startDate = document.getElementById('stats-start-date').value;
                const endDate = document.getElementById('stats-end-date').value;

                const response = await hass.callWS({
                    type: 'call_service',
                    domain: 'pill_assistant',
                    service: 'get_statistics',
                    service_data: {
                        start_date: startDate,
                        end_date: endDate,
                        medication_id: medId
                    },
                    return_response: true
                });

                // Update the header to show it's filtered
                const header = document.querySelector('.statistics-header h2');
                if (header) {
                    header.textContent = `Statistics for ${medName}`;
                }

                // Use centralized helper to unwrap response
                const stats = unwrapServiceResponse(response) || { total_entries: 0, medications: {}, daily_counts: {} };
                currentStats = stats;
                
                renderStatistics(currentStats);
                
            } catch (error) {
                console.error('Error loading medication statistics:', error);
            }
        }

        // Load next schedule cache from localStorage
        function loadNextScheduleCache() {
            const saved = localStorage.getItem('pillAssistantNextScheduleCache');
            if (saved) {
                try {
                    nextScheduleCache = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading next schedule cache:', e);
                    nextScheduleCache = {};
                }
            }
        }

        // Save next schedule cache to localStorage
        function saveNextScheduleCache() {
            localStorage.setItem('pillAssistantNextScheduleCache', JSON.stringify(nextScheduleCache));
        }

        // Update next schedule cache for a medication
        function updateNextScheduleCache(medId, nextDoseTime) {
            nextScheduleCache[medId] = nextDoseTime;
            saveNextScheduleCache();
        }

        // Get cached next schedule for a medication
        function getCachedNextSchedule(medId) {
            return nextScheduleCache[medId];
        }

        // Helper function to refresh hass connection
        function refreshHassConnection() {
            const newHass = getHassConnection();
            if (newHass) {
                hass = newHass;
            }
            return hass;
        }

        // Helper function to find medication card by ID
        function findMedicationCard(medId) {
            const cards = document.querySelectorAll('[data-entity-id]');
            for (const card of cards) {
                const entityId = card.getAttribute('data-entity-id');
                if (entityId && entityId.includes(medId)) {
                    // Verify it's an exact match by checking if it's the full entity ID
                    // Note: We check both 'Medication ID' (human-friendly display name) and 
                    // 'medication_id' (legacy technical name) for backward compatibility
                    const medication = medications.find(m => 
                        (m.attributes['Medication ID'] === medId || m.attributes['medication_id'] === medId)
                    );
                    if (medication && entityId === medication.entityId) {
                        return card;
                    }
                }
            }
            return null;
        }

        // Format time to local 12-hour format with AM/PM
        function formatTimeToLocal(timeStr) {
            if (!timeStr || timeStr === 'Never' || timeStr === 'Unknown' || timeStr === 'Not scheduled') {
                return timeStr;
            }
            
            try {
                // Try to parse as ISO datetime string
                let date = new Date(timeStr);
                
                // Check if it's a valid date
                if (isNaN(date.getTime())) {
                    // Try parsing HH:MM format
                    const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})/);
                    if (timeMatch) {
                        const hours = parseInt(timeMatch[1]);
                        const minutes = parseInt(timeMatch[2]);
                        const period = hours >= 12 ? 'PM' : 'AM';
                        const displayHours = hours % 12 || 12;
                        return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
                    }
                    return timeStr; // Return as-is if can't parse
                }
                
                // Format to local 12-hour time with AM/PM
                return date.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
            } catch (e) {
                console.warn('Error formatting time:', timeStr, e);
                return timeStr;
            }
        }

        // Format schedule to show times in local format and prettify days
        function formatSchedule(schedule) {
            if (!schedule || schedule === 'Not scheduled') {
                return schedule;
            }
            
            // Parse times from schedule string (e.g., "08:00, 20:00 on mon, tue, wed, thu, fri, sat, sun")
            const timePattern = /(\d{1,2}:\d{2})/g;
            const times = schedule.match(timePattern);
            
            let result = schedule;
            
            if (times && times.length > 0) {
                const formattedTimes = times.map(time => formatTimeToLocal(time));
                times.forEach((time, i) => {
                    result = result.replace(time, formattedTimes[i]);
                });
            }
            
            // Format days of the week to be more readable
            const dayMappings = {
                'mon': 'Mon',
                'tue': 'Tue',
                'wed': 'Wed',
                'thu': 'Thu',
                'fri': 'Fri',
                'sat': 'Sat',
                'sun': 'Sun'
            };
            
            // Replace lowercase day abbreviations with capitalized versions
            Object.entries(dayMappings).forEach(([short, formatted]) => {
                // Match word boundaries to avoid partial replacements
                const regex = new RegExp('\\b' + short + '\\b', 'gi');
                result = result.replace(regex, formatted);
            });
            
            // Check if all 7 days are included - replace with "Daily"
            const allDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const daysInSchedule = allDays.filter(day => result.includes(day));
            if (daysInSchedule.length === 7) {
                // Replace the days list with "Daily"
                result = result.replace(/on\s+Mon,?\s*Tue,?\s*Wed,?\s*Thu,?\s*Fri,?\s*Sat,?\s*Sun/i, 'Daily');
            } else if (daysInSchedule.length >= 5) {
                // Check for weekdays only
                const weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
                const weekdaysInSchedule = weekdays.filter(day => result.includes(day));
                const weekendInSchedule = ['Sat', 'Sun'].filter(day => result.includes(day));
                if (weekdaysInSchedule.length === 5 && weekendInSchedule.length === 0) {
                    result = result.replace(/on\s+Mon,?\s*Tue,?\s*Wed,?\s*Thu,?\s*Fri/i, 'Weekdays');
                }
            }
            
            return result;
        }

        // Format medication type from snake_case to Title Case
        function formatMedicationType(type) {
            if (!type) return '';
            // Replace underscores with spaces, then capitalize each word
            return type
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        }

        // Get Home Assistant connection
        function getHassConnection() {
            if (window.parent && window.parent.document) {
                const haElement = window.parent.document.querySelector('home-assistant');
                if (haElement && haElement.hass) {
                    return haElement.hass;
                }
            }
            return null;
        }

        // Initialize connection to Home Assistant
        let retryCount = 0;
        function initConnection() {
            // Initialize theme first
            initTheme();
            
            // Load settings
            loadSettings();
            loadNextScheduleCache();
            
            hass = getHassConnection();
            if (hass) {
                loadMedications();
            } else {
                retryCount++;
                if (retryCount < 10) {
                    // Retry after a short delay
                    setTimeout(initConnection, 500);
                } else {
                    // Show message if not embedded in HA frontend
                    document.getElementById('content').innerHTML = `
                        <div style="text-align: center; padding: 60px 20px; color: var(--secondary-text-color, #757575);">
                            <h2 style="margin-bottom: 20px;">‚ö†Ô∏è Not Embedded in Home Assistant</h2>
                            <p style="margin-bottom: 15px;">This panel should be accessed via the Home Assistant sidebar.</p>
                            <p style="margin-bottom: 15px;">To add it to the sidebar:</p>
                            <ol style="text-align: left; max-width: 500px; margin: 0 auto;">
                                <li style="margin-bottom: 10px;">Go to <strong>Settings ‚Üí Dashboards</strong></li>
                                <li style="margin-bottom: 10px;">Click <strong>Add Dashboard</strong></li>
                                <li style="margin-bottom: 10px;">Select <strong>Panel (sidebar)</strong></li>
                                <li style="margin-bottom: 10px;">Set URL to <code>/pill_assistant/pill-assistant-panel.html</code></li>
                                <li style="margin-bottom: 10px;">Set title to <strong>Pill Assistant</strong></li>
                                <li style="margin-bottom: 10px;">Set icon to <strong>mdi:pill</strong></li>
                            </ol>
                        </div>
                    `;
                }
            }
        }

        // Load medications from Home Assistant
        async function loadMedications() {
            try {
                if (!hass) {
                    hass = getHassConnection();
                    if (!hass) {
                        throw new Error('Home Assistant connection not available');
                    }
                }

                // Get all entities
                const states = hass.states;
                medications = [];

                // Filter for pill assistant sensors
                for (const entityId in states) {
                    if (entityId.startsWith('sensor.pa_')) {
                        const entity = states[entityId];
                        medications.push({
                            entityId: entityId,
                            state: entity.state,
                            attributes: entity.attributes
                        });
                        
                        // Cache next schedule time
                        const medId = entity.attributes['Medication ID'] || entity.attributes['medication_id'];
                        const nextDose = entity.attributes['Next dose time'] || entity.attributes['next_dose_time'];
                        if (medId && nextDose) {
                            updateNextScheduleCache(medId, nextDose);
                        }
                    }
                }

                renderMedications();
            } catch (error) {
                console.error('Error loading medications:', error);
                document.getElementById('content').innerHTML = `
                    <div class="error">
                        <strong>Error:</strong> Failed to load medications. ${error.message}
                    </div>
                `;
            }
        }

        // Render medications
        function renderMedications() {
            const content = document.getElementById('content');

            if (medications.length === 0) {
                content.innerHTML = `
                    <div class="empty-state">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M4.22,11.29L11.29,4.22C13.64,1.88 17.43,1.88 19.78,4.22C22.12,6.56 22.12,10.36 19.78,12.71L12.71,19.78C10.36,22.12 6.56,22.12 4.22,19.78C1.88,17.43 1.88,13.64 4.22,11.29M5.64,12.71C4.59,13.75 4.24,15.24 4.6,16.57L10.59,10.59L14.83,14.83L18.36,11.29C19.93,9.73 19.93,7.2 18.36,5.64C16.8,4.07 14.27,4.07 12.71,5.64L5.64,12.71Z" />
                        </svg>
                        <h2>No Medications Found</h2>
                        <p>Add medications through Settings ‚Üí Devices & Services ‚Üí Add Integration ‚Üí Pill Assistant</p>
                    </div>
                `;
                return;
            }

            // Sort medications by next_dose_time (next scheduled first)
            const sortedMedications = [...medications].sort((a, b) => {
                const aNextDose = a.attributes['Next dose time'] || a.attributes['next_dose_time'];
                const bNextDose = b.attributes['Next dose time'] || b.attributes['next_dose_time'];
                
                // Handle medications with no next dose (put them at the end)
                if (!aNextDose || aNextDose === 'Unknown' || aNextDose === 'Never') return 1;
                if (!bNextDose || bNextDose === 'Unknown' || bNextDose === 'Never') return -1;
                
                // Parse dates and compare
                const aDate = new Date(aNextDose);
                const bDate = new Date(bNextDose);
                
                // Invalid dates go to the end
                if (isNaN(aDate.getTime())) return 1;
                if (isNaN(bDate.getTime())) return -1;
                
                return aDate - bDate;
            });

            let html = '';
            sortedMedications.forEach(med => {
                html += renderMedicationCard(med);
            });

            content.innerHTML = html;
        }

        // Render individual medication card
        function renderMedicationCard(med) {
            const attrs = med.attributes;
            const medId = attrs['Medication ID'] || attrs['medication_id'] || '';
            const dosage = attrs['dosage'] || attrs['Dosage'] || '1';
            const dosageUnit = attrs['dosage_unit'] || attrs['Dosage unit'] || 'each';
            const medicationTypeRaw = attrs['medication_type'] || attrs['Medication Type'] || 'pill';
            const medicationType = formatMedicationType(medicationTypeRaw);
            const remaining = attrs['remaining_amount'] || attrs['Remaining amount'] || 0;
            const lastTaken = formatTimeToLocal(attrs['Last taken at'] || attrs['last_taken'] || 'Never');
            const schedule = formatSchedule(attrs['Schedule'] || 'Not scheduled');
            
            // Use cached next dose time if available, otherwise get from attributes
            let nextDose = attrs['Next dose time'] || attrs['next_dose_time'] || 'Unknown';
            const cachedNextDose = getCachedNextSchedule(medId);
            if (cachedNextDose && cachedNextDose !== 'Unknown') {
                nextDose = cachedNextDose;
            }
            nextDose = formatTimeToLocal(nextDose);
            
            const refillAmount = attrs['Refill amount'] || 0;
            const medName = med.entityId.replace('sensor.pa_', '').replace(/_/g, ' ');
            
            // Helper to check if decrement button should be disabled
            const isDecrementDisabled = parseFloat(dosage) <= 0.5;
            const isRemainingDecrementDisabled = parseFloat(remaining) <= 0;

            return `
                <div class="medication-card" data-entity-id="${med.entityId}">
                    <div class="medication-header">
                        <div class="medication-name">${medName}</div>
                        <div class="medication-status status-${med.state}">${med.state}</div>
                    </div>

                    <div class="medication-details">
                        <div class="detail-item">
                            <div class="detail-label">Type</div>
                            <div class="detail-value">${medicationType}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Schedule</div>
                            <div class="detail-value">${schedule}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Remaining Amount</div>
                            <div class="detail-value">${remaining} ${dosageUnit}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Last Taken</div>
                            <div class="detail-value">${lastTaken}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Next Dose</div>
                            <div class="detail-value">${nextDose}</div>
                        </div>
                    </div>

                    <div class="adjusters-container">
                        <div class="dosage-adjuster">
                            <div class="dosage-label">Dosage:</div>
                            <div class="dosage-controls">
                                <button class="dosage-btn" onclick="adjustDosage('${medId}', -1)" ${isDecrementDisabled ? 'disabled' : ''}>‚àí</button>
                                <div class="dosage-value">${dosage} ${medicationType}(s) (${dosageUnit})</div>
                                <button class="dosage-btn" onclick="adjustDosage('${medId}', 1)">+</button>
                            </div>
                        </div>

                        <div class="dosage-adjuster">
                            <div class="dosage-label">Remaining:</div>
                            <div class="dosage-controls">
                                <button class="dosage-btn" onclick="adjustRemaining('${medId}', -1)" ${isRemainingDecrementDisabled ? 'disabled' : ''}>‚àí</button>
                                <div class="dosage-value">${remaining} ${medicationType}(s) (${dosageUnit})</div>
                                <button class="dosage-btn" onclick="adjustRemaining('${medId}', 1)">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="action-buttons">
                        <button class="action-btn btn-take" onclick="takeMedication('${medId}')">
                            Mark as Taken
                        </button>
                        <button class="action-btn btn-skip" onclick="skipMedication('${medId}')">
                            Skip Dose
                        </button>
                        <button class="action-btn btn-refill" onclick="refillMedication('${medId}')">
                            Refill
                        </button>
                        <button class="action-btn btn-test" onclick="testNotification('${medId}')">
                            Test Notification
                        </button>
                    </div>

                    <div class="card-management-actions">
                        <button class="action-btn btn-stats" onclick="showMedicationStats('${medId}', '${medName}')">
                            üìä Statistics
                        </button>
                        <button class="action-btn btn-edit" onclick="editMedication('${medId}')">
                            ‚úèÔ∏è Edit
                        </button>
                        <button class="action-btn btn-delete" onclick="deleteMedication('${medId}', '${medName}')">
                            üóëÔ∏è Delete
                        </button>
                    </div>
                </div>
            `;
        }

        // Call Home Assistant service
        async function callService(domain, service, serviceData) {
            try {
                if (!hass) {
                    hass = getHassConnection();
                    if (!hass) {
                        throw new Error('Home Assistant connection not available');
                    }
                }

                // Mark card as updating using exact entity ID match
                const medId = serviceData.medication_id;
                const targetCard = findMedicationCard(medId);
                
                if (targetCard) {
                    targetCard.classList.add('updating');
                }

                await hass.callService(domain, service, serviceData);
                
                // Wait a bit for state to update in backend
                await new Promise(resolve => setTimeout(resolve, STATE_UPDATE_DELAY_MS));
                
                // Refresh hass connection to get latest states
                refreshHassConnection();
                
                // Immediately reload medications for instant feedback
                await loadMedications();
                
                showSuccessMessage(`Action completed successfully!`);
                
                // Remove updating class
                if (targetCard) {
                    targetCard.classList.remove('updating');
                }
            } catch (error) {
                console.error('Error calling service:', error);
                showErrorMessage(`Error: ${error.message}`);
                
                // Remove updating class on error
                const medId = serviceData.medication_id;
                const errorCard = findMedicationCard(medId);
                if (errorCard) {
                    errorCard.classList.remove('updating');
                }
            }
        }

        // Show success message
        function showSuccessMessage(message) {
            showNotification(message, 'success');
        }

        // Show error message
        function showErrorMessage(message) {
            showNotification(message, 'error');
        }

        // Show notification message
        function showNotification(message, type = 'success') {
            // Only show success notifications if the banner is enabled
            if (type === 'success' && !showConfirmationBanner) {
                return;
            }
            
            const msgEl = document.createElement('div');
            msgEl.className = type === 'error' ? 'error-message' : 'success-message';
            msgEl.textContent = message;
            document.body.appendChild(msgEl);

            setTimeout(() => {
                msgEl.remove();
            }, 3000);
        }

        // Medication actions
        async function takeMedication(medId) {
            await callService('pill_assistant', 'take_medication', { medication_id: medId });
            
            // After taking medication, check if there's no next schedule
            setTimeout(async () => {
                await checkAndPromptNextSchedule(medId);
            }, STATE_UPDATE_DELAY_MS + 200);
        }

        // Check if medication has no next schedule and prompt user
        async function checkAndPromptNextSchedule(medId) {
            try {
                // Reload medications to get latest state
                await loadMedications();
                
                // Find the medication
                const med = medications.find(m => 
                    m.attributes['Medication ID'] === medId || 
                    m.attributes['medication_id'] === medId
                );
                
                if (!med) {
                    return;
                }
                
                const nextDose = med.attributes['Next dose time'] || med.attributes['next_dose_time'];
                
                // If there's no next dose scheduled, prompt user
                if (!nextDose || nextDose === 'Unknown' || nextDose === 'None') {
                    // Sanitize medication name for display
                    const medName = med.entityId
                        .replace('sensor.pa_', '')
                        .replace(/_/g, ' ')
                        .replace(/[<>'"]/g, ''); // Remove potentially problematic characters
                    
                    const now = new Date();
                    const defaultTime = now.toTimeString().slice(0, 5); // HH:MM format
                    
                    // Create a timeout promise (5 minutes) with cleanup
                    let timeoutId;
                    const timeoutPromise = new Promise(resolve => {
                        timeoutId = setTimeout(() => resolve(null), 300000); // 5 minutes
                    });
                    
                    // Use prompt (will replace with custom modal in future enhancement)
                    // Note: This is a temporary solution, a custom modal would provide better UX
                    const inputPromise = new Promise(resolve => {
                        try {
                            const userInput = prompt(
                                `${medName} has no next scheduled dose.\n\n` +
                                `When should the next dose be taken?\n` +
                                `Format: HH:MM (24-hour) or HH:MM AM/PM\n\n` +
                                `Leave empty or click Cancel to use the current time (${defaultTime})`,
                                defaultTime
                            );
                            resolve(userInput);
                        } catch (error) {
                            console.warn('Prompt blocked or failed:', error);
                            resolve(null);
                        }
                    });
                    
                    // Wait for either user input or timeout
                    const userTime = await Promise.race([inputPromise, timeoutPromise]);
                    
                    // Clear timeout to prevent memory leak
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    
                    // If timeout or empty, use default time
                    const timeToUse = userTime || defaultTime;
                    
                    console.log(`Next dose time set to: ${timeToUse} for ${medName}`);
                    // Note: This would require backend support to actually set the next dose time
                    // For now, we just cache it locally
                    updateNextScheduleCache(medId, timeToUse);
                }
            } catch (error) {
                console.error('Error checking next schedule:', error);
            }
        }

        async function skipMedication(medId) {
            await callService('pill_assistant', 'skip_medication', { medication_id: medId });
        }

        async function refillMedication(medId) {
            await callService('pill_assistant', 'refill_medication', { medication_id: medId });
        }

        async function testNotification(medId) {
            await callService('pill_assistant', 'test_notification', { medication_id: medId });
        }

        async function adjustDosage(medId, change) {
            const service = change > 0 ? 'increment_dosage' : 'decrement_dosage';
            await callService('pill_assistant', service, { medication_id: medId });
        }

        async function adjustRemaining(medId, change) {
            const service = change > 0 ? 'increment_remaining' : 'decrement_remaining';
            await callService('pill_assistant', service, { medication_id: medId });
        }

        // Add medication - opens config flow
        async function addMedication() {
            try {
                if (!hass) {
                    throw new Error('Home Assistant connection not available');
                }

                // Navigate to the config flow for adding a new medication
                const domain = 'pill_assistant';
                const path = `/config/integrations/dashboard/add?domain=${domain}`;
                
                // Navigate using Home Assistant's navigation pattern
                if (window.parent && window.parent.history) {
                    try {
                        window.parent.history.pushState(null, '', path);
                        window.parent.dispatchEvent(new CustomEvent('location-changed', {
                            detail: { replace: false }
                        }));
                    } catch (navError) {
                        console.error('Navigation error:', navError);
                        throw new Error('Cannot navigate - not embedded in Home Assistant');
                    }
                } else {
                    throw new Error('Cannot navigate - not embedded in Home Assistant');
                }
            } catch (error) {
                console.error('Error adding medication:', error);
                showErrorMessage(`Error: ${error.message}. Please add medication through Settings ‚Üí Devices & Services ‚Üí Add Integration ‚Üí Pill Assistant`);
            }
        }

        // Edit medication - opens options flow
        async function editMedication(medId) {
            try {
                if (!hass) {
                    throw new Error('Home Assistant connection not available');
                }

                // Note: medId is the medication_id attribute, which is actually the entry_id
                // We need to navigate to the config entry's options flow
                // The correct URL format is: /config/integrations/config_entry/{entry_id}
                const path = `/config/integrations/config_entry/${medId}`;
                
                // Try multiple navigation methods for better compatibility with side panel
                let navigationSuccess = false;
                
                // Method 1: Try using hass.navigate if available (preferred for panels)
                if (typeof hass.navigate === 'function') {
                    try {
                        hass.navigate(path);
                        navigationSuccess = true;
                    } catch (navError) {
                        console.warn('hass.navigate failed:', navError);
                    }
                }
                
                // Method 2: Try using parent window navigation
                if (!navigationSuccess && window.parent && window.parent !== window) {
                    try {
                        // Try to access the Home Assistant main element for navigation
                        const haElement = window.parent.document.querySelector('home-assistant');
                        if (haElement && haElement.hass && typeof haElement.hass.navigate === 'function') {
                            haElement.hass.navigate(path);
                            navigationSuccess = true;
                        } else if (window.parent.history) {
                            // Fallback to direct history manipulation
                            window.parent.history.pushState(null, '', path);
                            window.parent.dispatchEvent(new CustomEvent('location-changed', {
                                detail: { replace: false }
                            }));
                            navigationSuccess = true;
                        }
                    } catch (navError) {
                        console.warn('Parent window navigation failed:', navError);
                    }
                }
                
                if (!navigationSuccess) {
                    throw new Error('Cannot navigate - not embedded in Home Assistant or navigation unavailable');
                }
            } catch (error) {
                console.error('Error editing medication:', error);
                showErrorMessage(`Error: ${error.message}. Please edit medication through Settings ‚Üí Devices & Services ‚Üí Configure`);
            }
        }

        // Delete medication - removes config entry
        async function deleteMedication(medId, medName) {
            try {
                if (!hass) {
                    throw new Error('Home Assistant connection not available');
                }

                // Confirm deletion
                if (!confirm(`Are you sure you want to delete ${medName}? This will remove all data for this medication.`)) {
                    return;
                }

                // Note: medId is the config entry ID (entry_id)
                // Call the config_entries.remove service to delete the medication
                await hass.callService('config_entries', 'remove', {
                    entry_id: medId
                });
                
                showSuccessMessage(`${medName} deleted successfully!`);
                
                // Reload medications
                await loadMedications();
            } catch (error) {
                console.error('Error deleting medication:', error);
                showErrorMessage(`Error deleting medication: ${error.message}`);
            }
        }

        // Initialize on load
        initConnection();

        // Subscribe to Home Assistant state changes for real-time updates
        function subscribeToStateChanges() {
            if (!hass) {
                return false;
            }

            // Subscribe to state changes using hass connection
            if (hass.connection && hass.connection.subscribeEvents) {
                hass.connection.subscribeEvents(
                    async (event) => {
                        // Check if the changed entity is a pill assistant sensor
                        if (event.data && event.data.entity_id && 
                            event.data.entity_id.startsWith('sensor.pa_')) {
                            console.log('Pill Assistant state changed:', event.data.entity_id);
                            
                            // Refresh hass connection to get latest states
                            refreshHassConnection();
                            
                            // Reload medications with updated state
                            await loadMedications();
                        }
                    },
                    'state_changed'
                ).catch(err => {
                    console.warn('Failed to subscribe to state changes:', err);
                });
                return true;
            }
            return false;
        }

        // Try to subscribe with retry logic
        let subscribeAttempts = 0;
        function attemptSubscription() {
            if (subscribeAttempts >= SUBSCRIPTION_MAX_ATTEMPTS) {
                console.warn(`Failed to subscribe to state changes after ${SUBSCRIPTION_MAX_ATTEMPTS} attempts`);
                return;
            }
            
            subscribeAttempts++;
            if (!subscribeToStateChanges()) {
                // Retry with exponential backoff
                const delay = Math.min(
                    SUBSCRIPTION_BASE_DELAY_MS * subscribeAttempts, 
                    SUBSCRIPTION_MAX_DELAY_MS
                );
                setTimeout(attemptSubscription, delay);
            } else {
                console.log('Successfully subscribed to state changes');
            }
        }
        
        // Start subscription attempts after connection is ready
        attemptSubscription();

        // Refresh medications every 30 seconds as fallback
        setInterval(() => {
            if (hass) {
                loadMedications();
            }
        }, POLL_INTERVAL_MS);

        // ============== Statistics and Visualization Functions ==============
        
        let trendsChart = null;
        let adherenceChart = null;
        let currentStats = null;

        // Switch between tabs
        function switchTab(tabName, event) {
            // Update tab buttons
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // If no event, find and activate the correct tab button
                tabs.forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(tabName.toLowerCase())) {
                        tab.classList.add('active');
                    }
                });
            }

            // Update tab content
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');

            // Load statistics when switching to statistics tab
            if (tabName === 'statistics') {
                initStatistics();
            }
        }

        // Initialize statistics section
        function initStatistics() {
            // Set default to today (with checkbox checked)
            setToday();
        }

        // Set date range to today only
        function setToday() {
            const today = new Date();
            document.getElementById('stats-start-date').valueAsDate = today;
            document.getElementById('stats-end-date').valueAsDate = today;
            
            // Check the today checkbox
            const checkbox = document.getElementById('stats-today-checkbox');
            if (checkbox) {
                checkbox.checked = true;
            }
            
            // Reset time inputs to full day
            document.getElementById('stats-start-time').value = '00:00';
            document.getElementById('stats-end-time').value = '23:59';
            
            // Auto-load statistics
            loadStatistics();
        }

        // Set date range to last 7 days
        function setLast7Days() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);

            document.getElementById('stats-start-date').valueAsDate = startDate;
            document.getElementById('stats-end-date').valueAsDate = endDate;
            
            // Reset time inputs to full day range
            document.getElementById('stats-start-time').value = '00:00';
            document.getElementById('stats-end-time').value = '23:59';
            
            // Uncheck the today checkbox since we're using a different range
            const checkbox = document.getElementById('stats-today-checkbox');
            if (checkbox) {
                checkbox.checked = false;
            }
            
            // Auto-load statistics
            loadStatistics();
        }

        // Set date range to last 30 days
        function setLast30Days() {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30);

            document.getElementById('stats-start-date').valueAsDate = startDate;
            document.getElementById('stats-end-date').valueAsDate = endDate;
            
            // Reset time inputs to full day range
            document.getElementById('stats-start-time').value = '00:00';
            document.getElementById('stats-end-time').value = '23:59';
            
            // Uncheck the today checkbox since we're using a different range
            const checkbox = document.getElementById('stats-today-checkbox');
            if (checkbox) {
                checkbox.checked = false;
            }
            
            // Auto-load statistics
            loadStatistics();
        }

        // Handle date range change - auto-refresh when dates are manually changed
        function onDateRangeChange() {
            // Uncheck the today checkbox since user is manually selecting dates
            const checkbox = document.getElementById('stats-today-checkbox');
            if (checkbox) {
                checkbox.checked = false;
            }
            
            // Debounce to prevent rapid successive API calls when user changes multiple fields
            if (dateChangeDebounceTimer) {
                clearTimeout(dateChangeDebounceTimer);
            }
            dateChangeDebounceTimer = setTimeout(() => {
                loadStatistics();
            }, DATE_CHANGE_DEBOUNCE_MS);
        }

        // Load statistics from backend
        async function loadStatistics() {
            try {
                if (!hass) {
                    throw new Error('Home Assistant connection not available');
                }

                const startDate = document.getElementById('stats-start-date').value;
                const endDate = document.getElementById('stats-end-date').value;
                const startTime = document.getElementById('stats-start-time').value || '00:00';
                const endTime = document.getElementById('stats-end-time').value || '23:59';

                if (!startDate || !endDate) {
                    showErrorMessage('Please select both start and end dates');
                    return;
                }

                // Combine date and time for full datetime
                const startDateTime = new Date(`${startDate}T${startTime}:00`);
                const endDateTime = new Date(`${endDate}T${endTime}:59`);

                // Use callWS with return_response: true to properly receive service responses
                // This is the correct method for services that support response data
                let response = null;
                try {
                    response = await hass.callWS({
                        type: 'call_service',
                        domain: 'pill_assistant',
                        service: 'get_statistics',
                        service_data: {
                            start_date: startDateTime.toISOString(),
                            end_date: endDateTime.toISOString()
                        },
                        return_response: true
                    });
                } catch (wsError) {
                    // Fallback: If callWS fails (older HA version), try callService
                    console.warn('callWS failed, falling back to callService:', wsError);
                    response = await hass.callService(
                        'pill_assistant',
                        'get_statistics',
                        {
                            start_date: startDateTime.toISOString(),
                            end_date: endDateTime.toISOString()
                        }
                    );
                }

                // Use centralized helper to unwrap response
                if (response && typeof response === 'object') {
                    console.debug('Pill Assistant: Statistics service response received', response);
                } else {
                    console.warn('Pill Assistant: Unexpected response type from statistics service', typeof response);
                }
                
                const stats = unwrapServiceResponse(response);
                
                if (!stats) {
                    console.warn('No statistics data received from service');
                    showErrorMessage('No statistics data available. Please ensure medications have been logged.');
                    // Set empty stats to clear any previous data
                    currentStats = {
                        total_entries: 0,
                        medications: {},
                        daily_counts: {},
                        action_counts: {}
                    };
                } else {
                    currentStats = stats;
                }
                
                renderStatistics(currentStats);
            } catch (error) {
                console.error('Error loading statistics:', error);
                showErrorMessage(`Failed to load statistics: ${error.message}`);
            }
        }

        // Render statistics summary and charts
        function renderStatistics(stats) {
            if (!stats) return;

            // Render summary cards
            renderSummaryStats(stats);

            // Render charts
            renderTrendsChart(stats);
            renderAdherenceChart(stats);
            
            // Load clock data for the selected date if picker exists
            const datePicker = document.getElementById('clock-date-picker');
            if (datePicker && datePicker.value) {
                loadClockData(datePicker.value);
            }
        }

        // Render summary statistics cards
        function renderSummaryStats(stats) {
            const summaryEl = document.getElementById('stats-summary');
            
            const totalMeds = Object.keys(stats.medications || {}).length;
            const totalTaken = Object.values(stats.medications || {}).reduce(
                (sum, med) => sum + (med.taken_count || 0), 0
            );
            const totalSkipped = Object.values(stats.medications || {}).reduce(
                (sum, med) => sum + (med.skipped_count || 0), 0
            );
            const adherenceRate = totalTaken + totalSkipped > 0
                ? Math.round((totalTaken / (totalTaken + totalSkipped)) * 100)
                : 0;

            summaryEl.innerHTML = `
                <div class="stat-card">
                    <h3>Total Medications</h3>
                    <div class="stat-value">${totalMeds}</div>
                </div>
                <div class="stat-card">
                    <h3>Doses Taken</h3>
                    <div class="stat-value">${totalTaken}</div>
                </div>
                <div class="stat-card">
                    <h3>Doses Skipped</h3>
                    <div class="stat-value">${totalSkipped}</div>
                </div>
                <div class="stat-card">
                    <h3>Adherence Rate</h3>
                    <div class="stat-value">${adherenceRate}%</div>
                </div>
            `;
        }

        // Render trends chart (medications taken over time)
        function renderTrendsChart(stats) {
            const ctx = document.getElementById('trendsChart');
            if (!ctx) return;

            // Destroy existing chart
            if (trendsChart) {
                trendsChart.destroy();
                trendsChart = null;
            }

            // Prepare data by date
            const dailyCounts = stats.daily_counts || {};
            const dates = Object.keys(dailyCounts).sort();
            
            // Get all medication IDs
            const medIds = new Set();
            Object.values(dailyCounts).forEach(day => {
                Object.keys(day).forEach(medId => medIds.add(medId));
            });
            
            // Handle empty data case
            if (dates.length === 0 || medIds.size === 0) {
                console.debug('Pill Assistant: No data available for trends chart');
                // Create empty chart with message
                trendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    }
                });
                return;
            }

            // Determine chart type based on current selection
            const isScatterPlot = currentChartType === 'plot';
            
            // Prepare datasets for each medication
            const datasets = Array.from(medIds).map((medId, index) => {
                const medData = stats.medications[medId] || {};
                const medName = medData.name || medId;
                
                // Generate distinct colors for each medication using golden angle
                // Golden angle (137.5¬∞) provides optimal color distribution
                const hue = (index * 137.5) % 360;
                const color = `hsl(${hue}, 70%, 50%)`;
                const borderColor = `hsl(${hue}, 70%, 40%)`;
                const ALPHA_50_PERCENT = '80'; // Hex for 50% transparency
                
                if (isScatterPlot) {
                    // For scatter plot, create data points with x,y coordinates
                    const scatterData = dates.map((date, dateIndex) => {
                        const dayData = dailyCounts[date][medId];
                        return {
                            x: dateIndex,
                            y: dayData ? dayData.taken : 0
                        };
                    });
                    
                    return {
                        label: medName,
                        data: scatterData,
                        backgroundColor: color,
                        borderColor: borderColor,
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        showLine: false
                    };
                } else {
                    // For bar/line chart
                    const data = dates.map(date => {
                        const dayData = dailyCounts[date][medId];
                        return dayData ? dayData.taken : 0;
                    });

                    return {
                        label: medName,
                        data: data,
                        borderColor: borderColor,
                        backgroundColor: color + ALPHA_50_PERCENT,
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4
                    };
                }
            });

            // Determine if we're in dark mode
            const isDarkMode = document.body.classList.contains('theme-dark');
            const textColor = isDarkMode ? '#e0e0e0' : '#212121';
            const gridColor = isDarkMode ? '#444' : '#e0e0e0';

            // Use scatter type for scatter plot, line for default
            const chartType = isScatterPlot ? 'scatter' : 'line';
            
            trendsChart = new Chart(ctx, {
                type: chartType,
                data: {
                    labels: dates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: isScatterPlot ? 'nearest' : 'index',
                        intersect: isScatterPlot,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: textColor,
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: isDarkMode ? '#1e1e1e' : '#ffffff',
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: gridColor,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                title: function(context) {
                                    if (isScatterPlot) {
                                        const dateIndex = Math.round(context[0].parsed.x);
                                        return 'Date: ' + (dates[dateIndex] || '');
                                    }
                                    return 'Date: ' + context[0].label;
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y + ' dose(s)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: textColor,
                                stepSize: 1
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        x: isScatterPlot ? {
                            type: 'linear',
                            position: 'bottom',
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    const dateIndex = Math.round(value);
                                    return dates[dateIndex] || '';
                                },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: gridColor
                            }
                        } : {
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
        }

        // Render adherence chart (taken vs scheduled by medication)
        function renderAdherenceChart(stats) {
            const ctx = document.getElementById('adherenceChart');
            if (!ctx) return;

            // Destroy existing chart
            if (adherenceChart) {
                adherenceChart.destroy();
                adherenceChart = null;
            }

            const medications = stats.medications || {};
            const medNames = [];
            const takenCounts = [];
            const skippedCounts = [];
            const colors = [];

            Object.entries(medications).forEach(([medId, medData], index) => {
                medNames.push(medData.name || medId);
                takenCounts.push(medData.taken_count || 0);
                skippedCounts.push(medData.skipped_count || 0);
                
                // Generate distinct colors
                const hue = (index * 137.5) % 360;
                colors.push(`hsl(${hue}, 70%, 50%)`);
            });
            
            // Handle empty data case
            if (medNames.length === 0) {
                console.debug('Pill Assistant: No data available for adherence chart');
                // Create empty chart
                adherenceChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    }
                });
                return;
            }

            // Determine if we're in dark mode
            const isDarkMode = document.body.classList.contains('theme-dark');
            const textColor = isDarkMode ? '#e0e0e0' : '#212121';
            const gridColor = isDarkMode ? '#444' : '#e0e0e0';

            adherenceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: medNames,
                    datasets: [
                        {
                            label: 'Taken',
                            data: takenCounts,
                            backgroundColor: '#4caf50',
                            borderColor: '#45a049',
                            borderWidth: 1
                        },
                        {
                            label: 'Skipped',
                            data: skippedCounts,
                            backgroundColor: '#ff9800',
                            borderColor: '#f57c00',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: textColor,
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: isDarkMode ? '#1e1e1e' : '#ffffff',
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: gridColor,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                label: function(context) {
                                    const total = takenCounts[context.dataIndex] + skippedCounts[context.dataIndex];
                                    const percentage = total > 0 
                                        ? Math.round((context.parsed.y / total) * 100)
                                        : 0;
                                    return context.dataset.label + ': ' + context.parsed.y + ' (' + percentage + '%)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: textColor,
                                stepSize: 1
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        x: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
        }

        // ============== Clock Visualization Functions ==============
        
        let clockPeriod = 'AM'; // Current selected period for 12hr clock
        let clockData = []; // Store dose events by date
        let show24HourClock = false; // Whether to show 24-hour clock

        // Get local date string in YYYY-MM-DD format
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Initialize clock date picker to today
        function initClockDatePicker() {
            const datePicker = document.getElementById('clock-date-picker');
            if (datePicker) {
                const today = new Date();
                const dateStr = getLocalDateString(today);
                datePicker.value = dateStr;
                
                // Set max date to today
                datePicker.max = dateStr;
                
                // Load data for today
                loadClockData(dateStr);
            }
        }

        // Toggle 24-hour clock visibility
        function toggle24HourClock() {
            const checkbox = document.getElementById('show-24hr-clock');
            show24HourClock = checkbox ? checkbox.checked : false;
            
            const wrapper24hr = document.getElementById('clock-24hr-wrapper');
            if (wrapper24hr) {
                wrapper24hr.style.display = show24HourClock ? 'flex' : 'none';
            }
            
            // Save preference
            localStorage.setItem('pillAssistantShow24HrClock', show24HourClock ? 'true' : 'false');
            
            // Re-render if showing
            if (show24HourClock) {
                render24HourClock();
            }
        }

        // Load 24-hour clock preference
        function load24HourClockPreference() {
            const saved = localStorage.getItem('pillAssistantShow24HrClock');
            show24HourClock = saved === 'true';
            
            const checkbox = document.getElementById('show-24hr-clock');
            if (checkbox) {
                checkbox.checked = show24HourClock;
            }
            
            const wrapper24hr = document.getElementById('clock-24hr-wrapper');
            if (wrapper24hr) {
                wrapper24hr.style.display = show24HourClock ? 'flex' : 'none';
            }
        }

        // Toggle between AM/PM for 12hr clock
        function toggleClockPeriod(period) {
            clockPeriod = period;
            document.getElementById('am-btn').classList.toggle('active', period === 'AM');
            document.getElementById('pm-btn').classList.toggle('active', period === 'PM');
            renderClocks();
        }

        // Load medication dose data for a specific date
        async function loadClockData(dateStr) {
            try {
                if (!hass) {
                    hass = getHassConnection();
                    if (!hass) {
                        console.error('Home Assistant connection not available');
                        return;
                    }
                }

                // Call the statistics service for the selected date using callWS for response
                // Convert date strings to ISO format to match how bar/scatter charts fetch data
                const datePattern = /^\d{4}-\d{2}-\d{2}$/;
                if (!datePattern.test(dateStr)) {
                    console.warn('Invalid date format for clock data:', dateStr);
                    return;
                }
                
                // Create proper ISO date strings for start and end of the day
                const startDateISO = new Date(dateStr).toISOString();
                const endDateISO = new Date(dateStr + 'T23:59:59').toISOString();
                
                let response = null;
                try {
                    response = await hass.callWS({
                        type: 'call_service',
                        domain: 'pill_assistant',
                        service: 'get_statistics',
                        service_data: {
                            start_date: startDateISO,
                            end_date: endDateISO
                        },
                        return_response: true
                    });
                } catch (wsError) {
                    console.warn('callWS failed for clock data:', wsError);
                    // Fallback to callService
                    try {
                        response = await hass.callService(
                            'pill_assistant',
                            'get_statistics',
                            {
                                start_date: startDateISO,
                                end_date: endDateISO
                            }
                        );
                    } catch (serviceError) {
                        console.warn('callService also failed for clock data:', serviceError);
                    }
                }

                console.debug('Clock data loaded for', dateStr, response);
                
                // Use centralized helper to unwrap response
                const stats = unwrapServiceResponse(response);
                
                // Parse the dose events from the response
                clockData = parseDoseEvents(stats, dateStr);
                renderClocks();
                
            } catch (error) {
                console.error('Error loading clock data:', error);
                clockData = [];
                renderClocks();
            }
        }

        // Parse dose events from statistics response
        function parseDoseEvents(stats, dateStr) {
            const events = [];
            
            if (!stats || !stats.medications) {
                return events;
            }

            // Iterate through each medication's events
            Object.entries(stats.medications).forEach(([medId, medData]) => {
                const medName = medData.name || medId;
                
                // Check for taken events
                if (medData.taken_times && Array.isArray(medData.taken_times)) {
                    medData.taken_times.forEach(timeStr => {
                        try {
                            const eventDate = new Date(timeStr);
                            if (isNaN(eventDate.getTime())) return;
                            const dateOnly = getLocalDateString(eventDate);
                            if (dateOnly === dateStr) {
                                events.push({
                                    time: eventDate,
                                    type: 'taken',
                                    medication: medName
                                });
                            }
                        } catch (e) {
                            console.warn('Error parsing taken time:', timeStr, e);
                        }
                    });
                }
                
                // Check for skipped events
                if (medData.skipped_times && Array.isArray(medData.skipped_times)) {
                    medData.skipped_times.forEach(timeStr => {
                        try {
                            const eventDate = new Date(timeStr);
                            if (isNaN(eventDate.getTime())) return;
                            const dateOnly = getLocalDateString(eventDate);
                            if (dateOnly === dateStr) {
                                events.push({
                                    time: eventDate,
                                    type: 'skipped',
                                    medication: medName
                                });
                            }
                        } catch (e) {
                            console.warn('Error parsing skipped time:', timeStr, e);
                        }
                    });
                }
                
                // Check for snoozed events (treat as delayed)
                if (medData.snoozed_times && Array.isArray(medData.snoozed_times)) {
                    medData.snoozed_times.forEach(timeStr => {
                        try {
                            const eventDate = new Date(timeStr);
                            if (isNaN(eventDate.getTime())) return;
                            const dateOnly = getLocalDateString(eventDate);
                            if (dateOnly === dateStr) {
                                events.push({
                                    time: eventDate,
                                    type: 'delayed',
                                    medication: medName
                                });
                            }
                        } catch (e) {
                            console.warn('Error parsing snoozed time:', timeStr, e);
                        }
                    });
                }
            });
            
            return events;
        }

        // Render both clock visualizations
        function renderClocks() {
            const datePicker = document.getElementById('clock-date-picker');
            if (!datePicker || !datePicker.value) {
                return;
            }
            
            render12HourClock();
            render24HourClock();
        }

        // Render 12-hour clock with wedges
        function render12HourClock() {
            const svg = document.getElementById('clock-12hr');
            if (!svg) return;
            
            // Clear existing content
            svg.innerHTML = '';
            
            // Draw clock face
            drawClockFace(svg, 12);
            
            // Filter events for the selected period (AM/PM)
            const filteredEvents = clockData.filter(event => {
                const hours = event.time.getHours();
                if (clockPeriod === 'AM') {
                    return hours < 12;
                } else {
                    return hours >= 12;
                }
            });
            
            // Draw wedges for each event
            filteredEvents.forEach(event => {
                const hours = event.time.getHours() % 12 || 12;
                const minutes = event.time.getMinutes();
                const angle = ((hours + minutes / 60) / 12) * 360;
                
                drawWedge(svg, angle, event.type, event.medication, event.time);
            });
        }

        // Render 24-hour clock with wedges
        function render24HourClock() {
            const svg = document.getElementById('clock-24hr');
            if (!svg) return;
            
            // Clear existing content
            svg.innerHTML = '';
            
            // Draw clock face
            drawClockFace(svg, 24);
            
            // Draw wedges for all events
            clockData.forEach(event => {
                const hours = event.time.getHours();
                const minutes = event.time.getMinutes();
                const angle = ((hours + minutes / 60) / 24) * 360;
                
                drawWedge(svg, angle, event.type, event.medication, event.time);
            });
        }

        // Draw clock face with hour markers
        function drawClockFace(svg, maxHours) {
            const isDarkMode = document.body.classList.contains('theme-dark');
            const faceColor = isDarkMode ? '#2a2a2a' : '#ffffff';
            const lineColor = isDarkMode ? '#444' : '#e0e0e0';
            const textColor = isDarkMode ? '#e0e0e0' : '#212121';
            
            // Draw outer circle
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '0');
            circle.setAttribute('cy', '0');
            circle.setAttribute('r', '100');
            circle.setAttribute('fill', faceColor);
            circle.setAttribute('stroke', lineColor);
            circle.setAttribute('stroke-width', '2');
            svg.appendChild(circle);
            
            // Draw hour markers and labels
            for (let i = 0; i < maxHours; i++) {
                const angle = (i / maxHours) * 360 - 90; // Start from top (12 o'clock position)
                const radians = angle * Math.PI / 180;
                
                // Draw hour line
                const x1 = Math.cos(radians) * 90;
                const y1 = Math.sin(radians) * 90;
                const x2 = Math.cos(radians) * 100;
                const y2 = Math.sin(radians) * 100;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', lineColor);
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
                
                // Draw hour label (only every N hours for readability)
                const labelInterval = maxHours === 24 ? 6 : 3;
                if (i % labelInterval === 0) {
                    const labelX = Math.cos(radians) * 75;
                    const labelY = Math.sin(radians) * 75;
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', labelX);
                    text.setAttribute('y', labelY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', textColor);
                    text.setAttribute('font-size', '12');
                    text.setAttribute('font-weight', '500');
                    text.textContent = maxHours === 24 ? i : (i === 0 ? 12 : i);
                    svg.appendChild(text);
                }
            }
        }

        // Draw a wedge for a dose event extending from center outward
        function drawWedge(svg, angle, type, medication, eventTime) {
            // Determine color based on type
            let color;
            switch (type) {
                case 'taken':
                    color = '#4caf50'; // Green
                    break;
                case 'delayed':
                    color = '#ffc107'; // Yellow
                    break;
                case 'skipped':
                    color = '#f44336'; // Red
                    break;
                default:
                    color = '#9e9e9e'; // Gray for unknown
            }
            
            // Wedge parameters - wedge extends FROM CENTER outward past clock face
            const innerRadius = 0; // Start from center of clock
            const outerRadius = 115; // Extend slightly beyond clock face (100)
            const wedgeWidth = 5; // Degrees of arc for each wedge
            
            // Convert angle to radians (adjust so 0¬∞ is at top)
            const startAngle = (angle - wedgeWidth / 2 - 90) * Math.PI / 180;
            const endAngle = (angle + wedgeWidth / 2 - 90) * Math.PI / 180;
            
            // Calculate path points for outer arc
            const x2 = Math.cos(startAngle) * outerRadius;
            const y2 = Math.sin(startAngle) * outerRadius;
            const x3 = Math.cos(endAngle) * outerRadius;
            const y3 = Math.sin(endAngle) * outerRadius;
            
            // Create path for wedge from center (0,0) to outer arc
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M 0,0 L ${x2},${y2} A ${outerRadius},${outerRadius} 0 0,1 ${x3},${y3} Z`;
            path.setAttribute('d', pathData);
            path.setAttribute('fill', color);
            path.setAttribute('fill-opacity', '0.8');
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '1');
            path.setAttribute('class', 'clock-wedge');
            
            // Add title for tooltip
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            let timeStr = '';
            if (eventTime) {
                timeStr = eventTime.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
            }
            title.textContent = `${medication} - ${type}${timeStr ? ' at ' + timeStr : ''}`;
            path.appendChild(title);
            
            svg.appendChild(path);
        }

        // Event handler for date picker change
        document.addEventListener('DOMContentLoaded', function() {
            initClockDatePicker();
            loadSizingSettings();
            loadChartTypePreference();
            load24HourClockPreference();
            
            // Re-render clocks when switching tabs
            const statsTab = document.getElementById('nav-statistics-tab');
            if (statsTab) {
                statsTab.addEventListener('click', function() {
                    setTimeout(() => {
                        if (!clockData || clockData.length === 0) {
                            const datePicker = document.getElementById('clock-date-picker');
                            if (datePicker && datePicker.value) {
                                loadClockData(datePicker.value);
                            }
                        } else {
                            renderClocks();
                        }
                    }, 100);
                });
            }
        });
    </script>
</body>
</html>
